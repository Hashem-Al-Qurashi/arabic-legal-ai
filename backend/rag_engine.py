"""
Elite Legal RAG Engine - Production Ready with OpenAI Streaming
Clean architecture with domain-specific prompting and streaming support
"""

import os
import re
import asyncio
from enum import Enum
from typing import List, Dict, Optional, AsyncIterator, Tuple
from dataclasses import dataclass
from dotenv import load_dotenv
from openai import OpenAI, AsyncOpenAI  # โ Both sync and async clients
import markdown

# Load environment variables
try:
    load_dotenv(".env")
except:
    pass

DEEPSEEK_API_KEY = os.getenv("DEEPSEEK_API_KEY")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")  # ADD this line
AI_PROVIDER = os.getenv("AI_PROVIDER", "openai")  # ADD this line


if AI_PROVIDER == "openai" and OPENAI_API_KEY:
    openai_client = AsyncOpenAI(
        api_key=OPENAI_API_KEY,
        timeout=60.0,
        max_retries=2
    )
    sync_client = OpenAI(api_key=OPENAI_API_KEY)
elif DEEPSEEK_API_KEY:
    openai_client = AsyncOpenAI(
        api_key=DEEPSEEK_API_KEY,
        base_url="https://api.deepseek.com/v1",
        timeout=60.0,
        max_retries=2
    )
    sync_client = OpenAI(
        api_key=DEEPSEEK_API_KEY, 
        base_url="https://api.deepseek.com/v1"
    )
else:
    raise ValueError("โ No API key available")

# 4. NEW CLASSES (ADD these after client initialization)
class Domain(Enum):
    """Legal domains for specialized prompting"""
    LEGAL = "legal"
    FINANCE = "finance" 
    TECH = "tech"
    GENERAL = "general"

class Complexity(Enum):
    """Query complexity levels"""
    SIMPLE = "simple"
    COMPLEX = "complex"
    DOCUMENT = "document"

@dataclass
class PromptConfig:
    """Configuration for AI prompting"""
    domain: Domain
    complexity: Complexity
    max_tokens: int
    temperature: float

class DomainDetector:
    """Enhanced domain detection for comprehensive consultation service"""
    
    # ==================== EXPANDED KEYWORDS ====================
    
    LEGAL_KEYWORDS = [
        # Core legal terms
        "ูุงููู", "ูุงูููู", "ูุงููููุฉ", "ูุญููุฉ", "ุฏุนูู", "ูุถูุฉ", "ุญูู", "ูุธุงู", 
        "ูุงุถู", "ูุญุงูู", "ุนูุฏ", "ุนููุฏ", "ุงุชูุงููุฉ", "ุฏููุน", "ุงุณุชุฆูุงู", "ุชูููุฐ", 
        "ุฅุฌุฑุงุกุงุช", "ูุญุงููุฉ", "ุชุฑุงูุน", "ูุฑุงูุนุฉ",
        
        # Business legal
        "ุดุฑูุฉ", "ุดุฑูุงุช", "ุชุฃุณูุณ", "ุชุณุฌูู", "ุฑุฎุตุฉ", "ุชุฑุงุฎูุต", "ุณุฌู", "ุณุฌูุงุช",
        "ุชุฌุงุฑู", "ุชุฌุงุฑูุฉ", "ุงุณุชุซูุงุฑ", "ุดุฑุงูุฉ", "ุงูุฏูุงุฌ", "ุงุณุชุญูุงุฐ",
        
        # Employment law
        "ููุธู", "ููุธููู", "ุนูู", "ุนูุงู", "ูุธููุฉ", "ุฎุฏูุฉ", "ุฑุงุชุจ", "ุฃุฌุฑ",
        "ุฅุฌุงุฒุฉ", "ุงุณุชูุงูุฉ", "ูุตู", "ุงููุงุก", "ุชุนููุถ", "ููุงูุฃุฉ", "ุชุฃูููุงุช",
        
        # Civil law
        "ุญููู", "ุงูุชุฒุงูุงุช", "ูุณุคูููุฉ", "ุถุฑุฑ", "ุชุนููุถ", "ุถูุงู", "ููุงูุฉ",
        "ููููุฉ", "ุฅูุฌุงุฑ", "ุจูุน", "ุดุฑุงุก", "ูุจุฉ", "ูุตูุฉ", "ููุฑุงุซ",
        
        # Criminal law
        "ุฌุฑููุฉ", "ุฌุฑุงุฆู", "ุนููุจุฉ", "ุนููุจุงุช", "ุฌูุงุฆู", "ุฌูุญุฉ", "ูุฎุงููุฉ",
        "ุณุฌู", "ุบุฑุงูุฉ", "ูุตุงุต", "ุฏูุฉ", "ุชุนุฒูุฑ"
    ]
    
    FINANCE_KEYWORDS = [
        # Banking & loans
        "ุจูู", "ุจููู", "ูุตุฑู", "ูุตุงุฑู", "ูุฑุถ", "ูุฑูุถ", "ุชูููู", "ุงุฆุชูุงู",
        "ููุงุฆุฏ", "ุฑุจุง", "ูุฑุงุจุญุฉ", "ุฅุฌุงุฑุฉ", "ูุดุงุฑูุฉ", "ูุถุงุฑุจุฉ", "ุณูู",
        
        # Investments
        "ุงุณุชุซูุงุฑ", "ุงุณุชุซูุงุฑุงุช", "ุฃุณูู", "ุณูู", "ุณูุฏุงุช", "ุตููู", "ูุญูุธุฉ",
        "ุนูุงุฆุฏ", "ุฃุฑุจุงุญ", "ุฎุณุงุฆุฑ", "ูุฎุงุทุฑ", "ุชุฏุงูู", "ุจูุฑุตุฉ", "ุณูู ูุงูู",
        
        # Insurance & savings
        "ุชุฃููู", "ุชุฃูููุงุช", "ุงุฏุฎุงุฑ", "ุชูููุฑ", "ูุนุงุด", "ุชูุงุนุฏ", "ุตูุฏูู",
        
        # Accounting & tax
        "ูุญุงุณุจุฉ", "ููุฒุงููุฉ", "ุญุณุงุจุงุช", "ุถุฑูุจุฉ", "ุถุฑุงุฆุจ", "ุฒูุงุฉ", "ุฌูุงุฑู",
        "ูุงูู", "ูุงููุฉ", "ููุฏู", "ุณูููุฉ", "ุฑุฃุณ ูุงู", "ุชูููุฉ", "ุฅูุฑุงุฏุงุช"
    ]
    
    TECH_KEYWORDS = [
        # Software & development
        "ุชููู", "ุชูููุฉ", "ุชูููููุฌูุง", "ุจุฑูุฌุฉ", "ุจุฑุงูุฌ", "ุชุทุจูู", "ุชุทุจููุงุช",
        "ูููุน", "ููุงูุน", "ูุธุงู", "ุฃูุธูุฉ", "ูุงุนุฏุฉ ุจูุงูุงุช", "ุฎุงุฏู", "ุณูุฑูุฑ",
        
        # Security & infrastructure
        "ุฃูุงู", "ุญูุงูุฉ", "ุฃูู ุณูุจุฑุงูู", "ุงุฎุชุฑุงู", "ููุฑูุณ", "ุชุดููุฑ",
        "ุดุจูุฉ", "ุดุจูุงุช", "ุงูุชุฑูุช", "ูุงู ูุงู", "ุฎูุงุฏู", "ุณุญุงุจู", "ููุงูุฏ",
        
        # AI & modern tech
        "ุฐูู", "ุฐูุงุก ุงุตุทูุงุนู", "ุขูุฉ", "ุชุนูู", "ุจูุงูุงุช", "ุชุญููู", "ุฎูุงุฑุฒููุฉ",
        "ุฑููู", "ุฑูููุฉ", "ุชุญูู ุฑููู", "ููุตุฉ", "ููุตุงุช", "ุชูููุงุช ุญุฏูุซุฉ"
    ]
    
    # Enhanced document detection
    DOCUMENT_PHRASES = [
        # Legal documents
        "ุงูุฑุฏ ุงููุงูููู ุนูู ุฏุนูู", "ุฑุฏ ุนูู ุงูุฏุนูู", "ุฏููุน ูุงููููุฉ", "ูุฐูุฑุฉ ูุงููููุฉ",
        "ูุงุฆุญุฉ ุฏุนูู", "ุตูุบุฉ ุนูุฏ", "ูุณูุฏุฉ ุงุชูุงููุฉ", "ูููุฐุฌ ุนูุฏ", "ุตูุงุบุฉ ุนูุฏ",
        
        # Financial documents  
        "ุฏุฑุงุณุฉ ุฌุฏูู", "ุฎุทุฉ ุนูู", "ุชูุฑูุฑ ูุงูู", "ุชุญููู ูุงูู", "ููุฒุงููุฉ ุนููููุฉ",
        
        # Technical documents
        "ููุงุตูุงุช ูููุฉ", "ุชุตููู ูุธุงู", "ูููู ุชููู", "ุฎุทุฉ ุชุทููุฑ"
    ]
    
    @classmethod
    def detect_domain(cls, query: str) -> Domain:
        """Enhanced domain detection with fallback logic"""
        query_lower = query.lower()
        
        # Calculate scores for each domain
        legal_score = sum(1 for kw in cls.LEGAL_KEYWORDS if kw in query_lower)
        finance_score = sum(1 for kw in cls.FINANCE_KEYWORDS if kw in query_lower)
        tech_score = sum(1 for kw in cls.TECH_KEYWORDS if kw in query_lower)
        
        # Enhanced scoring with context
        total_words = len(query_lower.split())
        
        # Boost scores based on keyword density
        legal_density = legal_score / max(total_words, 1) * 100
        finance_density = finance_score / max(total_words, 1) * 100
        tech_density = tech_score / max(total_words, 1) * 100
        
        print(f"๐ Domain Detection: Legal={legal_score}({legal_density:.1f}%), Finance={finance_score}({finance_density:.1f}%), Tech={tech_score}({tech_density:.1f}%)")
        
        # Decision logic with minimum threshold
        if legal_score > 0 and (legal_score >= finance_score and legal_score >= tech_score):
            return Domain.LEGAL
        elif finance_score > 0 and finance_score >= tech_score:
            return Domain.FINANCE
        elif tech_score > 0:
            return Domain.TECH
        
        # Fallback: If query mentions consultation/advice, default to legal
        consultation_terms = ["ุงุณุชุดุงุฑุฉ", "ูุตูุญุฉ", "ูุดูุฑุฉ", "ุฑุฃู", "ุชูุฌูู", "ุฅุฑุดุงุฏ"]
        if any(term in query_lower for term in consultation_terms):
            print("๐ฏ Fallback: Consultation detected โ Legal domain")
            return Domain.LEGAL
            
        return Domain.GENERAL
    
    @classmethod  
    def detect_complexity(cls, query: str) -> Complexity:
        """Enhanced complexity detection"""
        query_lower = query.lower()
        
        # Check for document generation requests
        if any(phrase in query_lower for phrase in cls.DOCUMENT_PHRASES):
            return Complexity.DOCUMENT
        
        # Complex indicators
        complex_indicators = [
            "ุชุญููู", "ุงุณุชุฑุงุชูุฌูุฉ", "ุชูุตูู", "ุดุงูู", "ูุชูุฏู", "ุนููู", "ููุตู",
            "ุฏุฑุงุณุฉ", "ุจุญุซ", "ุชูููู", "ููุงุฑูุฉ", "ุฎุทุฉ", "ุจุฑูุงูุฌ", "ูููุฌูุฉ"
        ]
        
        # Length and complexity scoring
        word_count = len(query_lower.split())
        complex_terms = sum(1 for term in complex_indicators if term in query_lower)
        
        if complex_terms >= 2 or word_count > 20:
            return Complexity.COMPLEX
        elif complex_terms >= 1 or word_count > 10:
            return Complexity.COMPLEX
        
        return Complexity.SIMPLE    
    

class PromptBuilder:
    """Advanced prompt building with domain expertise"""
    
    # System prompts for different domains
    SYSTEM_PROMPTS = {
        Domain.LEGAL: """ุฃูุช ูุณุชุดุงุฑ ูุงูููู ุณุนูุฏู ูุชุฎุตุต ููุฑุฎุต ูุน ุฎุจุฑุฉ 20 ุนุงูุงู ูู ุงููุงููู ุงูุณุนูุฏู.

ุชุฎุตุตุงุชู:
- ุงููุงููู ุงูุชุฌุงุฑู ูุงูุดุฑูุงุช
- ูุงููู ุงูุนูู ูุงูุนูุงู
- ุงูุฃุญูุงู ุงูุดุฎุตูุฉ
- ุงููุงููู ุงูุฌูุงุฆู
- ุงููุงููู ุงูุฅุฏุงุฑู
- ุงููุงููู ุงูุนูุงุฑู

ุฃุณููุจ ุนููู:
- ุชุญููู ุฏููู ูุจูู ุนูู ุงููุตูุต ุงููุธุงููุฉ
- ุงุณุชุดูุงุฏ ุจุงูุณูุงุจู ุงููุถุงุฆูุฉ
- ูุบุฉ ูุงููููุฉ ูุงุถุญุฉ ูููููุฉ
- ุญููู ุนูููุฉ ูุงุจูุฉ ููุชุทุจูู""",

        Domain.FINANCE: """ุฃูุช ูุณุชุดุงุฑ ูุงูู ุณุนูุฏู ูุนุชูุฏ ูุน ุฎุจุฑุฉ 15 ุนุงูุงู ูู ุงูุฃุณูุงู ุงููุงููุฉ ุงูุณุนูุฏูุฉ.

ุชุฎุตุตุงุชู:
- ุงูุชุฎุทูุท ุงููุงูู ุงูุดุฎุตู
- ุงูุงุณุชุซูุงุฑ ูู ุงูุณูู ุงูุณุนูุฏู
- ุงูุชูููู ูุงููุฑูุถ
- ุงูุถุฑุงุฆุจ ูุงูุฒูุงุฉ
- ุฅุฏุงุฑุฉ ุงููุฎุงุทุฑ ุงููุงููุฉ

ุฃุณููุจ ุนููู:
- ุชุญููู ูุงูู ุฏููู
- ุชูุตูุงุช ูุจููุฉ ุนูู ุงูุจูุงูุงุช
- ูุฑุงุนุงุฉ ุงูุฃุญูุงู ุงูุดุฑุนูุฉ
- ุญููู ูุงููุฉ ุนูููุฉ""",

        Domain.TECH: """ุฃูุช ูููุฏุณ ุชููู ุณุนูุฏู ูุชุฎุตุต ูุน ุฎุจุฑุฉ 12 ุนุงูุงู ูู ุชุทููุฑ ุงูุฃูุธูุฉ ูุงูุญููู ุงูุชูููุฉ.

ุชุฎุตุตุงุชู:
- ุชุทููุฑ ุงูุฃูุธูุฉ ูุงูุชุทุจููุงุช
- ุงูุฃูู ุงูุณูุจุฑุงูู
- ุงูุญูุณุจุฉ ุงูุณุญุงุจูุฉ
- ุงูุฐูุงุก ุงูุงุตุทูุงุนู
- ุฅุฏุงุฑุฉ ุงูุจูุงูุงุช

ุฃุณููุจ ุนููู:
- ุญููู ุชูููุฉ ุนูููุฉ
- ูุฑุงุนุงุฉ ูุนุงููุฑ ุงูุฃูุงู
- ุชูุตูุงุช ูุงุจูุฉ ููุชุทุจูู
- ุดุฑุญ ุชููู ูุงุถุญ""",

        Domain.GENERAL: """ุฃูุช ูุณุชุดุงุฑ ุนุงู ูุชุฎุตุต ูู ุชูุฏูู ุงููุดูุฑุฉ ุงูุดุงููุฉ ูุน ุฎุจุฑุฉ ูุงุณุนุฉ ูู ูุฎุชูู ุงููุฌุงูุงุช.

ููุฌู:
- ุชุญููู ุดุงูู ููุชูุงุฒู
- ุญููู ุนูููุฉ ููุจุชูุฑุฉ
- ูุบุฉ ูุงุถุญุฉ ููููููุฉ
- ูุฑุงุนุงุฉ ุงูุณูุงู ุงูุณุนูุฏู"""
    }
    
    @classmethod
    def get_system_prompt(cls, domain: Domain) -> str:
        """Get system prompt for domain"""
        return cls.SYSTEM_PROMPTS.get(domain, cls.SYSTEM_PROMPTS[Domain.GENERAL])
    
    @classmethod
    def build_user_prompt(cls, query: str, domain: Domain, complexity: Complexity) -> str:
        """Build optimized user prompt based on domain and complexity"""
        
        if complexity == Complexity.DOCUMENT and domain == Domain.LEGAL:
            return cls._build_legal_document_prompt(query)
        elif complexity == Complexity.COMPLEX:
            return cls._build_complex_analysis_prompt(query, domain)
        else:
            return cls._build_simple_prompt(query, domain)
    
    @classmethod
    def _build_legal_document_prompt(cls, query: str) -> str:
        """Build prompt for legal document generation"""
        return f"""ูู ุจุฅุนุฏุงุฏ ุฑุฏ ูุงูููู ูุชูุฏู ููุชููุฒ:

{query}

ูุชุทูุจุงุช ุงูุฑุฏ ุงููุงูููู:

๐๏ธ **ุงููููู ุงูุงุณุชุฑุงุชูุฌู:**
- ุชุฑุชูุจ ุงูุญุฌุฌ ูุฑููุงู (ุงูุฃููู ุฃููุงู)
- ูุบุฉ ูุงููููุฉ ูุฑูุฒุฉ ููููุฉ
- ุฑุจุท ูุจุงุดุฑ ุจุงููุตูุต ุงููุธุงููุฉ

โ๏ธ **ุงูุฃุณุณ ุงููุงููููุฉ:**
- ุงูุงุณุชุดูุงุฏ ุจุงูููุงุฏ ุงููุธุงููุฉ ุฐุงุช ุงูุตูุฉ
- ุฐูุฑ ุงูุณูุงุจู ุงููุถุงุฆูุฉ ุงูููุงุซูุฉ
- ุชุญุฏูุฏ ุงูุฃุฏูุฉ ูุงููุณุชูุฏุงุช ุงููุทููุจุฉ

๐ฏ **ุงูุงุณุชุฑุงุชูุฌูุฉ ุงููุงููููุฉ:**
- ุชุญููู ููุงุท ุงูููุฉ ูุงูุถุนู
- ุงูุฏููุน ุงููุงููููุฉ ุงููุชุงุญุฉ
- ุงูุทูุจุงุช ูุงูุชูุตูุงุช ุงูุนูููุฉ

๐ **ุงูุชูููุฐ ุงูุนููู:**
- ุฎุทูุงุช ุฅุฌุฑุงุฆูุฉ ูุญุฏุฏุฉ
- ุฌุฏูู ุฒููู ููุชูููุฐ
- ุงููุณุชูุฏุงุช ุงููุทููุจุฉ

ูุฌุจ ุฃู ูููู ุงูุฑุฏ ูุงุจูุงู ููุชูุฏูู ุฃูุงู ุงููุญููุฉ ููุทุงุจูุงู ููุฃุตูู ุงููุงููููุฉ."""
    
    @classmethod
    def _build_complex_analysis_prompt(cls, query: str, domain: Domain) -> str:
        """Build prompt for complex analysis"""
        domain_context = {
            Domain.LEGAL: "ูุงููููุฉ",
            Domain.FINANCE: "ูุงููุฉ", 
            Domain.TECH: "ุชูููุฉ",
            Domain.GENERAL: "ุดุงููุฉ"
        }
        
        context = domain_context.get(domain, "ุดุงููุฉ")
        
        return f"""ูุฏู ุงุณุชุดุงุฑุฉ {context} ูุชูุฏูุฉ ูููุตูุฉ:

{query}

ูุชุทูุจุงุช ุงูุชุญููู:

๐ฏ **ุงูุชุญููู ุงูุงุณุชุฑุงุชูุฌู:**
- ุชูููู ุดุงูู ูููุถุน ุงูุญุงูู
- ุชุญุฏูุฏ ุงููุฑุต ูุงูุชุญุฏูุงุช
- ุชุญููู ุงููุฎุงุทุฑ ูุงูุจุฏุงุฆู

๐ **ุงูุฃุณุณ ุงููุฑุฌุนูุฉ:**
- ุงูุงุณุชูุงุฏ ูููุฑุงุฌุน ูุงูุฃูุธูุฉ ุฐุงุช ุงูุตูุฉ
- ุชุญููู ุงูุณูุงุจู ูุงูุชุฌุงุฑุจ ุงูููุงุซูุฉ
- ูุฑุงุนุงุฉ ุงูุณูุงู ุงูุณุนูุฏู

๐ก **ุงูุชูุตูุงุช ุงูุนูููุฉ:**
- ุญููู ูุงุจูุฉ ููุชุทุจูู
- ุฎุทุฉ ุชูููุฐูุฉ ูุฑุญููุฉ
- ูุคุดุฑุงุช ุงููุฌุงุญ ูุงููุชุงุจุนุฉ

๐ **ุงูุชูุงุตูู ุงูุชูููุฐูุฉ:**
- ุงูุฎุทูุงุช ุงููุทููุจุฉ
- ุงูููุงุฑุฏ ูุงููุชุทูุจุงุช
- ุงูุฌุฏูู ุงูุฒููู ุงูููุชุฑุญ"""
    
    @classmethod
    def _build_simple_prompt(cls, query: str, domain: Domain) -> str:
        """Build prompt for simple queries"""
        return f"""ุฃุฌุจ ุนูู ุงูุณุคุงู ุงูุชุงูู ุจูุถูุญ ูุฏูุฉ:

{query}

ูุชุทูุจุงุช ุงูุฅุฌุงุจุฉ:
- ุฅุฌุงุจุฉ ูุจุงุดุฑุฉ ููุงุถุญุฉ
- ุชูุณูุฑ ูุจุณุท ุนูุฏ ุงูุญุงุฌุฉ  
- ุชูุตูุงุช ุนูููุฉ ูุฎุชุตุฑุฉ
- ูุฑุงุนุงุฉ ุงูุณูุงู ุงูุณุนูุฏู"""

class ConfigManager:
    """Manage AI configuration based on complexity"""
    
    CONFIGS = {
        Complexity.SIMPLE: PromptConfig(
            domain=Domain.GENERAL,
            complexity=Complexity.SIMPLE,
            max_tokens=2000,
            temperature=0.3
        ),
        Complexity.COMPLEX: PromptConfig(
            domain=Domain.GENERAL,
            complexity=Complexity.COMPLEX,
            max_tokens=4000,
            temperature=0.2
        ),
        Complexity.DOCUMENT: PromptConfig(
            domain=Domain.LEGAL,
            complexity=Complexity.DOCUMENT,
            max_tokens=6000,
            temperature=0.1
        )
    }
    
    @classmethod
    def get_config(cls, domain: Domain, complexity: Complexity) -> PromptConfig:
        """Get configuration for domain and complexity"""
        config = cls.CONFIGS[complexity]
        config.domain = domain
        return config

class RAGEngine:
    """Elite RAG Engine with streaming support"""
    
    def __init__(self):
        self.client = openai_client
        self.domain_detector = DomainDetector()
        self.prompt_builder = PromptBuilder()
        self.config_manager = ConfigManager()
    
    async def ask_question_streaming(self, query: str) -> AsyncIterator[str]:
        """Process question with streaming response"""
        try:
            # Detect domain and complexity
            domain = self.domain_detector.detect_domain(query)
            complexity = self.domain_detector.detect_complexity(query)
            
            print(f"๐ฏ Domain: {domain.value}, Complexity: {complexity.value}")
            
            # Get configuration
            config = self.config_manager.get_config(domain, complexity)
            
            # Build prompts
            system_prompt = self.prompt_builder.get_system_prompt(domain)
            user_prompt = self.prompt_builder.build_user_prompt(query, domain, complexity)
            
            # Create messages
            messages = [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ]
            
            # Stream response from OpenAI
            async for chunk in self._stream_openai_response(messages, config):
                yield chunk
                
        except Exception as e:
            print(f"โ Error in streaming: {e}")
            yield f"ุนุฐุฑุงูุ ุญุฏุซ ุฎุทุฃ ุชููู: {str(e)}"
    
    async def ask_question_with_context_streaming(
        self, 
        query: str, 
        conversation_history: List[Dict[str, str]]
    ) -> AsyncIterator[str]:
        """Process question with conversation context and streaming"""
        try:
            # Detect domain and complexity
            domain = self.domain_detector.detect_domain(query)
            complexity = self.domain_detector.detect_complexity(query)
            
            print(f"๐ฏ Context query - Domain: {domain.value}, Complexity: {complexity.value}")
            
            # Get configuration
            config = self.config_manager.get_config(domain, complexity)
            
            # Build messages with context
            messages = [
                {"role": "system", "content": self.prompt_builder.get_system_prompt(domain)}
            ]
            
            # Add conversation history (limit to last 8 messages)
            recent_history = conversation_history[-8:] if len(conversation_history) > 8 else conversation_history
            for msg in recent_history:
                messages.append({
                    "role": msg["role"],
                    "content": msg["content"]
                })
            
            # Add current query with context awareness
            contextual_prompt = f"ุจูุงุกู ุนูู ุณูุงู ุงููุญุงุฏุซุฉ ุงูุณุงุจูุฉุ {self.prompt_builder.build_user_prompt(query, domain, complexity)}"
            messages.append({
                "role": "user", 
                "content": contextual_prompt
            })
            
            # Stream response
            async for chunk in self._stream_openai_response(messages, config):
                yield chunk
                
        except Exception as e:
            print(f"โ Error in context streaming: {e}")
            yield f"ุนุฐุฑุงูุ ุญุฏุซ ุฎุทุฃ ุชููู: {str(e)}"
    
    async def _stream_openai_response(
        self, 
        messages: List[Dict[str, str]], 
        config: PromptConfig
    ) -> AsyncIterator[str]:
        """Stream response from OpenAI"""
        try:
            stream = await self.client.chat.completions.create(
                model="gpt-4o",  # Best model for Arabic legal work
                messages=messages,
                max_tokens=config.max_tokens,
                temperature=config.temperature,
                stream=True
            )
            
            async for chunk in stream:
                if chunk.choices[0].delta.content:
                    yield chunk.choices[0].delta.content
                    
        except Exception as e:
            print(f"โ OpenAI streaming error: {e}")
            raise
    
    async def generate_conversation_title(self, first_message: str) -> str:
        """Generate conversation title"""
        try:
            prompt = f"ุงูุชุฑุญ ุนููุงูุงู ูุฎุชุตุฑุงู ููุฐู ุงูุงุณุชุดุงุฑุฉ (ุฃูู ูู 40 ุญุฑู): {first_message[:150]}"
            
            response = await self.client.chat.completions.create(
                model="gpt-4o-mini",  # Faster model for titles
                messages=[{"role": "user", "content": prompt}],
                max_tokens=50,
                temperature=0.3
            )
            
            title = response.choices[0].message.content.strip()
            title = title.strip('"').strip("'").strip()
            
            # Remove common prefixes
            prefixes = ["ุงูุนููุงู:", "ุงูููุชุฑุญ:", "ุนููุงู:", "ุงูุงุณุชุดุงุฑุฉ:"]
            for prefix in prefixes:
                if title.startswith(prefix):
                    title = title[len(prefix):].strip()
            
            return title if len(title) <= 40 else title[:37] + "..."
            
        except Exception as e:
            print(f"โ Error generating title: {e}")
            return first_message[:25] + "..." if len(first_message) > 25 else first_message

# Global instance for easy import
rag_engine = RAGEngine()

# Legacy sync functions for backward compatibility
async def ask_question(query: str) -> str:
    """Legacy sync function - converts streaming to complete response"""
    chunks = []
    async for chunk in rag_engine.ask_question_streaming(query):
        chunks.append(chunk)
    return ''.join(chunks)

async def ask_question_with_context(query: str, conversation_history: List[Dict[str, str]]) -> str:
    """Legacy sync function with context - converts streaming to complete response"""
    chunks = []
    async for chunk in rag_engine.ask_question_with_context_streaming(query, conversation_history):
        chunks.append(chunk)
    return ''.join(chunks)

async def generate_conversation_title(first_message: str) -> str:
    """Legacy function for title generation"""
    return await rag_engine.generate_conversation_title(first_message)